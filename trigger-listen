#!/usr/bin/perl -w

use strict;
use lib "/opt/Daemon";
use Chj_library;


our $maxchildren= 10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname socketpath cmd [arguments]

  Listens on socketpath, and expects senders to print a 'trigger'
  line, and when that happens, after waiting for --sleep seconds
  ($sleeptime by default), runs the given cmd / arguments. If new
  triggers are being issued before the cmd finishes, it is being run
  again (thus no triggers are being missed).

  Options:
  --umask val  use umask instead of the current one (relevant for
               creating the socket file)
  --accept-arguments  instead of just the trigger message, accept
               messages with a list of strings encoded in them, which
               are then passed as additional arguments to cmd.
               Switches to piped handler, which does not have the
               property of running only once if before starting a run
               multiple triggers have been given, but instead runs as
               many times as triggers have been sent, but still
               serialized. Also switches off sleeping.

";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $DEBUG;
our $umask;
our $opt_accept_arguments;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "debug"=> \$DEBUG,
	   "umask=s"=> \$umask,
	   "accept-arguments"=>\$opt_accept_arguments,
	   ) or exit 1;
usage unless @ARGV >= 2;
$DEBUG||=$verbose;
our $socketpath= shift @ARGV;
our @cmd= @ARGV;

use IO::Socket::UNIX;

if (defined $umask) {
    umask oct($umask)
      or die "umask: $!";
}

unlink $socketpath; #okay?  check for running daemons...
our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Local=> $socketpath,
   Listen=> 1,
  )
  or die "opening socket '$socketpath': $!";#!

my $numchildren=0;

use POSIX ":sys_wait_h"; # WNOHANG

$SIG{CHLD}= do {
    my $pid;
    sub {
	while (1) {
	    $pid= waitpid -1,WNOHANG;
	    last if (($pid == -1) or ($pid == 0)); #GRR somehow mis documented??!
	    $numchildren--;
	}
    };
};


# --- main ----------------------------

eval {
    while(1) {
	my $conn= $socket->accept
	  or do {
	      if ($! == 4) {## get constant from POSIX ~
		  # OS error code   4:  Interrupted system call
		  redo
	      } else {
		  die "accept: $!";
	      }
	  };
	warn "got a connection from ".$conn->peername if $DEBUG;###todo convert to a human-readable something.
	if ($numchildren < $maxchildren) {
	    if (my $pid= xfork) {
		undef $conn;
		warn "forked off child $pid" if $DEBUG;
		$numchildren++; ###btw race! (in the ++ itself) hehhe.
	    } else {
		# start main program process
		my ($r,$w)= xpipe;
		if (my $pid= xfork) {
		    xclose $r;
		    my $buf;
		    while (read $conn, $buf, 2048) {
			print $w $buf
			  or die "writing to pipe to main program: $!"; ##todo SIGPIPE?  or  fork off handler first.
		    }
		    xclose $w;
		    waitpid $pid, 0
		      or die "waitpid $pid: $!";
		    my $exitcode= $?;
		    xprint $conn, $exitcode;
		    xclose $conn;
		    exit 0;
		} else {
		    xclose $w;
		    xexec $daemon;
		}
	    }
	} else {
	    warn "$myname: too many children, dropping connection\n";##from ...
	}
	warn "going to accept again" if $DEBUG;
    }
};
my $e=$@;
die $e;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
