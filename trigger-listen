#!/usr/bin/perl -w

use strict;
use lib "/opt/Daemon";
use Chj_library;


our $maxchildren= 10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Requires the DAEMON_SOCKET, DAEMON_SOCKET_GROUP, DAEMON_MAINPROGRAM
  env vars to be set.

  Optionally accepts DEBUG env var as boolean.

";
exit (@_ ? 1 : 0);
}

usage if @ARGV;
our $DEBUG= $ENV{DEBUG};
our $socketpath= xenv "DAEMON_SOCKET";
our $socket_group= xenv "DAEMON_SOCKET_GROUP";
our $mainprogram= xenv "DAEMON_MAINPROGRAM";

use IO::Socket::UNIX;

if (defined $umask) {
    umask oct($umask)
      or die "umask: $!";
}

unlink $socketpath; #okay?  check for running daemons...
our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Local=> $socketpath,
   Listen=> 1,
  )
  or die "opening socket '$socketpath': $!";#!

my $numchildren=0;

use POSIX ":sys_wait_h"; # WNOHANG

$SIG{CHLD}= do {
    my $pid;
    sub {
	while (1) {
	    $pid= waitpid -1,WNOHANG;
	    last if (($pid == -1) or ($pid == 0)); #GRR somehow mis documented??!
	    $numchildren--;
	}
    };
};


# --- main ----------------------------

eval {
    while(1) {
	my $conn= $socket->accept
	  or do {
	      if ($! == 4) {## get constant from POSIX ~
		  # OS error code   4:  Interrupted system call
		  redo
	      } else {
		  die "accept: $!";
	      }
	  };
	warn "got a connection from ".$conn->peername if $DEBUG;###todo convert to a human-readable something.
	if ($numchildren < $maxchildren) {
	    if (my $pid= xfork) {
		undef $conn;
		warn "forked off child $pid" if $DEBUG;
		$numchildren++; ###btw race! (in the ++ itself) hehhe.
	    } else {
		# start main program process
		my ($r,$w)= xpipe;
		if (my $pid= xfork) {
		    xclose $r;
		    my $buf;
		    while (read $conn, $buf, 2048) {
			print $w $buf
			  or die "writing to pipe to main program: $!"; ##todo SIGPIPE?  or  fork off handler first.
		    }
		    xclose $w;
		    waitpid $pid, 0
		      or die "waitpid $pid: $!";
		    my $exitcode= $?;
		    xprint $conn, $exitcode;
		    xclose $conn;
		    exit 0;
		} else {
		    xclose $w;
		    xexec $mainprogram;
		}
	    }
	} else {
	    warn "$myname: too many children, dropping connection\n";##from ...
	}
	warn "going to accept again" if $DEBUG;
    }
};
my $e=$@;
die $e;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
