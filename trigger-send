#!/usr/bin/perl -w

use strict;

our $default_timeout=10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [ arguments ]

  Ask the daemon listening at DAEMON_SOCKET to run its main program,
  passing arguments to it. Exit with the exit code of the main
  program, or if it was killed, report the signal and exit with an
  error code.

  Environment variables:
   required:
    DAEMON_SOCKET   path to communication socket

   optional:
    TIMEOUT   connect timeout in seconds, instead of the default $default_timeout

";
exit (@_ ? 1 : 0);
}

if (@ARGV==1 and ($ARGV[0] eq "-h" or
		  $ARGV[0] eq "--help")) {
    usage
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "timeout"=> \$timeout,
	   ) or exit 1;

our $timeout = do {
    if (defined $ENV{TIMEOUT}) {
	$ENV{TIMEOUT}=~ /^(\d+)$/
	  or die "invalid TIMEOUT variable '$TIMEOUT'";
	$1
    } else {
	$default_timeout
    }
};

our $socketpath= $ENV{DAEMON_SOCKET}
  or die "missing environment variable DAEMON_SOCKET";

use IO::Socket::UNIX;

$SIG{ALRM}= sub {
    die "$myname on '$socketpath': timed out\n";
};
alarm $timeout;

our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Peer=> $socketpath,
  )
  or die "opening socket '$socketpath': $!";#!

$socket->send(join("\0", @ARGV))
  or die "send: $!";

my $result= <$socket>;

my ($exitcode)= $result=~ /^(\d+)$/
  or die "invalid reply";

$socket->close
  or die "close: $!";

if ($exitcode==0 or $exitcode > 255) {
    exit ($exitcode << 8);
} else {
    die "$myname: remote process died with signal $exitcode\n";
}

