#!/usr/bin/perl -w

use strict;
use lib "/opt/Daemon";
use Chj_library;


our $bufsize= 4096; # bytes
our $default_maxmessagesize= 100; # number of buffers of $bufsize
our $default_maxchildren= 10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Requires the DAEMON_SOCKET, DAEMON_SOCKET_GROUP, and either
  DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV env vars to be
  set.

  Optionally accepts the environment variables:

    DEBUG as boolean

    DAEMON_MAXMESSAGESIZE (number of buffers of $bufsize bytes) to
    override the default of $default_maxmessagesize

    DAEMON_MAXCHILDREN (max. number of concurrently active
    mainprograms) to override the default of $default_maxchildren

";
exit (@_ ? 1 : 0);
}

usage if @ARGV;
our $DEBUG= $ENV{DEBUG};
our $socketpath= xenv "DAEMON_SOCKET";
our $socket_group= xenv "DAEMON_SOCKET_GROUP";
our $mainprogram_stdin= $ENV{DAEMON_MAINPROGRAM_STDIN};
our $mainprogram_argv= $ENV{DAEMON_MAINPROGRAM_ARGV};
our $maxmessagesize = $ENV{DAEMON_MAXMESSAGESIZE} || $default_maxmessagesize;
our $maxchildren= $ENV{DAEMON_MAXCHILDREN} || $default_maxchildren;

usage "only one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV can be given"
  if ($mainprogram_stdin and $mainprogram_argv);
usage "one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV must be given"
  unless ($mainprogram_stdin or $mainprogram_argv);

use IO::Socket::UNIX;

our $orig_umask= umask;

umask 0600
  or die "umask: $!";

unlink $socketpath; #okay?  check for running daemons...
our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Local=> $socketpath,
   Listen=> 1,
  )
  or die "opening socket '$socketpath': $!";#!

umask $orig_umask
  or die "umask: $!";

if (length $socket_group) {
    my @s= stat $socketpath or die;
    my $gid= getgrnam $socket_group
      or die "unknown group '$socket_group'";
    chown $s[4], $gid, $socketpath
      or die "chown: $!";
    chmod 0620, $socketpath
      or die "chmod: $!";
} else {
    chmod 0622, $socketpath
      or die "chmod: $!";
}


my $numchildren=0;

use POSIX ":sys_wait_h"; # WNOHANG

$SIG{CHLD}= do {
    my $pid;
    sub {
	while (1) {
	    $pid= waitpid -1,WNOHANG;
	    last if (($pid == -1) or ($pid == 0)); #GRR somehow mis documented??!
	    $numchildren--;
	}
    };
};


# --- main ----------------------------

    while(1) {
	my $conn= $socket->accept
	  or do {
	      if ($! == 4) {# XX: get constant from POSIX instead
		  # OS error code   4:  Interrupted system call
		  redo
	      } else {
		  die "accept: $!";
	      }
	  };
	warn "got a connection from ".$conn->peername if $DEBUG;
	# ^ XX: convert to a human-readable string
	if ($numchildren < $maxchildren) {
	    if (my $pid= xfork) {
		undef $conn;
		warn "forked off child $pid" if $DEBUG;
		$numchildren++;
		#^ XX: is there is a race (in the ++ itself) even with
		# Perl's safe signal handling?  In any case not very
		# likely, and the worst case is a DoS.
	    } else {
		# start main program process; choose the right data
		# passing mechanism according to the settings

		# regular finish:
		my $finish= sub {
		    my ($pid)=@_;
		    xwaitpid $pid, 0;
		    my $exitcode= $?;
		    warn "main process exited to $$, code $exitcode" if $DEBUG;
		    xprint_to $conn, "ok: $exitcode";
		    xclose $conn;
		    exit 0;
		};
		# abortive finish:
		my $abort_with_cleanup= sub {
		    my ($cleanup)=@_;
		    sub {
			warn "max message size has been exceeded, aborting (in daemon child $$)";
			&$cleanup;
			# send error to client:
			xprint_to $conn, "err: message too big";
			xclose $conn;
			# (success exit code since we are ok, the
			# error has been sent to the right place
			# already: )
			exit 0;
		    }
		};
		my $buf;
		my $while_read_buf= sub {
		    @_==2 or die;
		    my ($send_buf,$abort)=@_;
		    warn "reading connection in $$" if $DEBUG;
		    my $loop;
		    my $normal_end= sub {
			warn "finished reading in $$" if $DEBUG;
		    };
		    my $pipeerr_end= sub {
		    };
		    my $n=0;
		    $loop= sub {
			$n++;
			my $next=
			   (($n < $maxmessagesize) ?
			    ((read $conn, $buf, $bufsize) ?
			     &$send_buf($pipeerr_end, $loop)
			     :
			     $normal_end)
			    :
			    $abort);
			goto $next;
		    };
		    &$loop;
		    undef $loop # (break reference cycle)
		};
		$SIG{CHLD}= 'DEFAULT'; # not IGNORE, correct?
		if ($mainprogram_stdin) {
		    my $mainprogram= $mainprogram_stdin;

		    my ($r,$w)= xpipe;
		    if (my $pid= xfork) {
			xclose $r;
			$SIG{PIPE}= 'IGNORE';
			&$while_read_buf
			  (sub {
			       my ($stop,$continue)=@_;
			       # we don't die on errors, but signal
			       # $stop explicitely (capturing
			       # exceptions would be an alternative
			       # but I don't like examining exception
			       # texts to determine what happened)
			       if (print $w $buf) {
				   $continue
			       } else {
				   warn "writing to pipe to main program: $!";
				   $stop
			       }
			   },
			   &$abort_with_cleanup
			   (sub {
				# in case of abort, kill the child
				# (the child is not a process group
				# leader; running setsid in the child
				# would be a bad idea because that would
				# prevent individual mainprogram
				# invocations from being killed by
				# _startstop; or would that be ok?)
				kill 2, $pid;
				# don't care about child exit status.
				# but should we wait for it anyway? 
				# maybe a good idea.
				xwaitpid $pid, 0;
				warn "child $pid exited with $? (in $$)" if $DEBUG;
			    }));
			xclose $w;
			&$finish ($pid);
		    } else {
			xclose $w;
			xdup2 $r, 0;
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec $mainprogram;
		    }
		} else {
		    my $mainprogram= $mainprogram_argv;

		    my $input="";
		    &$while_read_buf
		      (sub {
			   my ($stop,$continue)=@_;
			   $input.=$buf;
			   $continue
		       },
		       &$abort_with_cleanup
		       (sub {
			    # just let it exit, we haven't started
			    # $mainprogram yet
			}));

		    # make sure empty arguments are not dropped, by
		    # requesting the field after the trailing marker,
		    # then popping it off
		    my @argv= split '\0', $input, -1;
		    pop @argv;

		    if (my $pid= xfork) {
			&$finish ($pid);
		    } else {
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec ("sh", "-c", $mainprogram,
			       # the first argument is passed to $0, not $1:
			       # (SERVICE_NAME would be useful to put
			       # here but is not necessarily set)
			       "mainprogram run from '$socketpath'",
			       @argv);
		    }
		}
	    }
	} else {
	    warn "$myname: too many children, dropping connection\n";##from ...
	}
	warn "going to accept again" if $DEBUG;
    }

