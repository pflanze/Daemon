#!/usr/bin/perl -w

use strict;
use lib "/opt/Daemon";
use Chj_library;


our $maxchildren= 10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Requires the DAEMON_SOCKET, DAEMON_SOCKET_GROUP, DAEMON_MAINPROGRAM
  env vars to be set.

  Optionally accepts DEBUG env var as boolean.

";
exit (@_ ? 1 : 0);
}

usage if @ARGV;
our $DEBUG= $ENV{DEBUG};
our $socketpath= xenv "DAEMON_SOCKET";
our $socket_group= xenv "DAEMON_SOCKET_GROUP";
our $mainprogram_stdin= $ENV{DAEMON_MAINPROGRAM_STDIN};
our $mainprogram_argv= $ENV{DAEMON_MAINPROGRAM_ARGV};

usage "only one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV can be given"
  if ($mainprogram_stdin and $mainprogram_argv);
usage "one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV must be given"
  unless ($mainprogram_stdin or $mainprogram_argv);

use IO::Socket::UNIX;

our $orig_umask= umask;

umask 0600
  or die "umask: $!";

unlink $socketpath; #okay?  check for running daemons...
our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Local=> $socketpath,
   Listen=> 1,
  )
  or die "opening socket '$socketpath': $!";#!

umask $orig_umask
  or die "umask: $!";

if (length $socket_group) {
    my @s= stat $socketpath or die;
    my $gid= getgrnam $socket_group
      or die "unknown group '$socket_group'";
    chown $s[4], $gid, $socketpath
      or die "chown: $!";
    chmod 0620, $socketpath
      or die "chmod: $!";
} else {
    chmod 0622, $socketpath
      or die "chmod: $!";
}


my $numchildren=0;

use POSIX ":sys_wait_h"; # WNOHANG

$SIG{CHLD}= do {
    my $pid;
    sub {
	while (1) {
	    $pid= waitpid -1,WNOHANG;
	    last if (($pid == -1) or ($pid == 0)); #GRR somehow mis documented??!
	    $numchildren--;
	}
    };
};


# --- main ----------------------------

eval {
    while(1) {
	my $conn= $socket->accept
	  or do {
	      if ($! == 4) {## get constant from POSIX ~
		  # OS error code   4:  Interrupted system call
		  redo
	      } else {
		  die "accept: $!";
	      }
	  };
	warn "got a connection from ".$conn->peername if $DEBUG;###todo convert to a human-readable something.
	if ($numchildren < $maxchildren) {
	    if (my $pid= xfork) {
		undef $conn;
		warn "forked off child $pid" if $DEBUG;
		$numchildren++; ###btw race! (in the ++ itself) hehhe.
	    } else {
		# start main program process; choose the right data
		# passing mechanism according to the settings

		my $finish= sub {
		    waitpid $pid, 0
		      or die "waitpid $pid: $!";
		    my $exitcode= $?;
		    warn "main process exited to $$, code $exitcode" if $DEBUG;
		    xprint_to $conn, $exitcode;
		    xclose $conn;
		    exit 0;
		};
		$SIG{CHLD}= 'DEFAULT'; # not IGNORE, correct?
		if ($mainprogram_stdin) {
		    my $mainprogram= $mainprogram_stdin;

		    my ($r,$w)= xpipe;
		    if (my $pid= xfork) {
			xclose $r;
			my $buf;
			$SIG{PIPE}= 'IGNORE';
			warn "copying connection in $$" if $DEBUG;
			while (read $conn, $buf, 2048) {
			    # don't die on errors
			    # (esp. because we need to send the result afterwards)
			    print $w $buf
			      or do {
				  warn "writing to pipe to main program: $!";
				  last;
			      };
			}
			warn "finished writing to main process in $$" if $DEBUG;
			xclose $w;
			&$finish;
		    } else {
			xclose $w;
			xdup2 $r, 0;
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec $mainprogram;
		    }
		} else {
		    my $mainprogram= $mainprogram_argv;

		    my $input="";
		    my $buf;
		    warn "reading connection in $$" if $DEBUG;
		    while (read $conn, $buf, 2048) {
			$input.=$buf;
		    }
		    warn "finished reading in $$" if $DEBUG;

		    my @argv= split '\0', $input, -1;
		    # pop off empty field after last zero byte
		    pop @argv;

		    if (my $pid= xfork) {
			&$finish;
		    } else {
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec "sh", "-c", $mainprogram, @argv;
		    }
		}
	    }
	} else {
	    warn "$myname: too many children, dropping connection\n";##from ...
	}
	warn "going to accept again" if $DEBUG;
    }
};
my $e=$@;
die $e;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
