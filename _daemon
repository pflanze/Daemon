#!/usr/bin/perl -w

use strict;
use lib "/opt/Daemon";
use Chj_library;


our $bufsize= 4096; # bytes
our $default_maxmessagesize= 100; # number of buffers of $bufsize
our $maxchildren= 10;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  Requires the DAEMON_SOCKET, DAEMON_SOCKET_GROUP, DAEMON_MAINPROGRAM
  env vars to be set.

  Optionally accepts the environment variables:

    DEBUG as boolean

    DAEMON_MAXMESSAGESIZE (number of buffers of $bufsize bytes) to
    override the default of $default_maxmessagesize

";
exit (@_ ? 1 : 0);
}

usage if @ARGV;
our $DEBUG= $ENV{DEBUG};
our $socketpath= xenv "DAEMON_SOCKET";
our $socket_group= xenv "DAEMON_SOCKET_GROUP";
our $mainprogram_stdin= $ENV{DAEMON_MAINPROGRAM_STDIN};
our $mainprogram_argv= $ENV{DAEMON_MAINPROGRAM_ARGV};
our $maxmessagesize = $ENV{DAEMON_MAXMESSAGESIZE} || $default_maxmessagesize;

usage "only one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV can be given"
  if ($mainprogram_stdin and $mainprogram_argv);
usage "one of DAEMON_MAINPROGRAM_STDIN or DAEMON_MAINPROGRAM_ARGV must be given"
  unless ($mainprogram_stdin or $mainprogram_argv);

use IO::Socket::UNIX;

our $orig_umask= umask;

umask 0600
  or die "umask: $!";

unlink $socketpath; #okay?  check for running daemons...
our $socket= IO::Socket::UNIX->new
  (
   Type=> SOCK_STREAM,
   Local=> $socketpath,
   Listen=> 1,
  )
  or die "opening socket '$socketpath': $!";#!

umask $orig_umask
  or die "umask: $!";

if (length $socket_group) {
    my @s= stat $socketpath or die;
    my $gid= getgrnam $socket_group
      or die "unknown group '$socket_group'";
    chown $s[4], $gid, $socketpath
      or die "chown: $!";
    chmod 0620, $socketpath
      or die "chmod: $!";
} else {
    chmod 0622, $socketpath
      or die "chmod: $!";
}


my $numchildren=0;

use POSIX ":sys_wait_h"; # WNOHANG

$SIG{CHLD}= do {
    my $pid;
    sub {
	while (1) {
	    $pid= waitpid -1,WNOHANG;
	    last if (($pid == -1) or ($pid == 0)); #GRR somehow mis documented??!
	    $numchildren--;
	}
    };
};


# --- main ----------------------------

eval {
    while(1) {
	my $conn= $socket->accept
	  or do {
	      if ($! == 4) {## get constant from POSIX ~
		  # OS error code   4:  Interrupted system call
		  redo
	      } else {
		  die "accept: $!";
	      }
	  };
	warn "got a connection from ".$conn->peername if $DEBUG;###todo convert to a human-readable something.
	if ($numchildren < $maxchildren) {
	    if (my $pid= xfork) {
		undef $conn;
		warn "forked off child $pid" if $DEBUG;
		$numchildren++; ###btw race! (in the ++ itself) hehhe.
	    } else {
		# start main program process; choose the right data
		# passing mechanism according to the settings

		# regular finish:
		my $finish= sub {
		    my ($pid)=@_;
		    xwaitpid $pid, 0;
		    my $exitcode= $?;
		    warn "main process exited to $$, code $exitcode" if $DEBUG;
		    xprint_to $conn, "ok: $exitcode";
		    xclose $conn;
		    exit 0;
		};
		# abortive finish:
		my $abort_with_cleanup= sub {
		    my ($cleanup)=@_;
		    sub {
			warn "max message size has been exceeded, aborting (in daemon child $$)";
			&$cleanup;
			# don't care about child exit status.
			# but should we wait for it anyway? maybe a good idea.
			xwaitpid $pid, 0;
			# send error to client:
			xprint_to $conn, "err: message too big";
			xclose $conn;
			# (success exit code since we are ok, the
			# error has been sent to the right place
			# already: )
			exit 0;
		    }
		};
		my $buf;
		my $while_read_buf= sub {
		    @_==2 or die;
		    my ($send_buf,$abort)=@_;
		    warn "reading connection in $$" if $DEBUG;
		    my $loop;
		    my $end= sub {
			undef $loop # (break reference cycle)
		    };
		    my $n=0;
		    $loop= sub {
			$n++;
			my $next=
			   (($n < $maxmessagesize) ?
			    ((read $conn, $buf, $bufsize) ?
			     &$send_buf($end, $loop)
			     :
			     $end)
			    :
			    $abort);
			goto $next;
		    };
		    &$loop;
		    warn "finished reading in $$" if $DEBUG;
		};
		$SIG{CHLD}= 'DEFAULT'; # not IGNORE, correct?
		if ($mainprogram_stdin) {
		    my $mainprogram= $mainprogram_stdin;

		    my ($r,$w)= xpipe;
		    if (my $pid= xfork) {
			xclose $r;
			$SIG{PIPE}= 'IGNORE';
			&$while_read_buf
			  (sub {
			       my ($stop,$continue)=@_;
			       # don't die on errors
			       # (esp. because we need to send the result afterwards)
			       if (print $w $buf) {
				   $continue
			       } else {
				   warn "writing to pipe to main program: $!";
				   $stop
			       }
			   },
			   &$abort_with_cleanup
			   (sub {
				# in case of abort, kill the child
				# (the child is not a process group
				# leader; running setsid in the child
				# would be a bad idea because that would
				# prevent individual mainprogram
				# invocations from being killed by
				# _startstop; or would that be ok?)
				kill 2, $pid
			    }));
			xclose $w;
			&$finish ($pid);
		    } else {
			xclose $w;
			xdup2 $r, 0;
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec $mainprogram;
		    }
		} else {
		    my $mainprogram= $mainprogram_argv;

		    my $input="";
		    &$while_read_buf
		      (sub {
			   my ($stop,$continue)=@_;
			   $input.=$buf;
			   $continue
		       },
		       &$abort_with_cleanup
		       (sub {
			    # in case of abort, just let it exit, we
			    # haven't started $mainprogram yet
			}));

		    my @argv= split '\0', $input, -1;
		    # pop off empty field after last zero byte
		    pop @argv;

		    if (my $pid= xfork) {
			&$finish ($pid);
		    } else {
			warn "going to exec in $$, '$mainprogram'" if $DEBUG;
			xexec "sh", "-c", $mainprogram, @argv;
		    }
		}
	    }
	} else {
	    warn "$myname: too many children, dropping connection\n";##from ...
	}
	warn "going to accept again" if $DEBUG;
    }
};
my $e=$@;
die $e;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
